---
title: "Flutter - 로컬 데이터베이스 ②: Future(데이터베이스 화면에 띄우기, FutureBuilder)"
date: 2022-01-15
categories:
  - Flutter
tags:
  - Flutter
use_math: true
---
<br>

데이터베이스에서 들고 와서 항목을 보여 주자

그냥 어떤 리스트 `List<Spec> SpecList`를 정의하고, async로 DB를 불러와 SpecList에 저장하고, 화면은 그냥 SpecList로 만든다고 치면 이상하게 동작할 거다  
DB를 읽는 도중에 이미 화면은 보여지기 때문에 빈 SpecList로 화면을 만들기 때문이다(비동기적).  

따라서 async 데이터를 화면에 보여줄 때는 Future를 사용해야 한다.
<br>

## Future, FutureBuilder

### Future

```dart
  Future<Database?> get database async {
    _database = await initDB();
    return _database;
  }
```
저번 글에서 데이터베이스 관련 함수는 다 `Future`, `async`를 썼다.  
`async`는 시간이 오래 걸릴 수 있는 일이기 때문에 비동기적으로 동작한다는 의미이며,  
`Future`는 그렇게 얻어온 데이터는 미래에? 얻을 수 있기 때문에 붙여주는 것

<br>

### FutureBuilder

```dart
body: FutureBuilder<List<Spec>>(
            future: _getDayQuery(),
            initialData: <Spec>[],
            builder: (context, snapshot) {
              return makeDayCon(snapshot.data);
            },
          )
```
화면을 만드는 `Widget build(BuildContext context)` 안에서 이런 async한 데이터로 위젯을 만들기 위해서는 `FutureBuilder`를 사용한다.  

**`future`**: async로 얻어올 데이터를 의미한다. 여기서는 `_getDayQuery()`라는 임의의 함수로 얻어오기로 한다.

**`initialData`**: async로 데이터를 얻어오기 전, 처음의 데이터를 의미한다. 보통 빈 리스트를 쓴다.

**`builder`**: 똑같이 위젯을 빌드해주면 된다. `snapshot`이 읽어 온 데이터를 의미한다.  
`snapshot.hasData` 등으로 일단 데이터를 가지고 있는 지 확인을 하면 좋다

```dart
body: FutureBuilder<List<Spec>>(
            future: _getDayQuery(),
            initialData: <Spec>[],
            builder: (context, snapshot) {
              return snapshot.hasData
                ? makeDayCon(snapshot.data)
                : Center( child: CircularProgressIndicator(),);
            },
          )
```
만약 `snapshot`이 데이터를 가지고 있다면 `makeDayCon()`이라는 임의의 함수로 읽어 온 데이터로 위젯을 빌드하고, 아니라면 `CircularProgressIndicator()`, 즉 로딩 원을 반환하는 코드다.  
그런데 쓰고 보니까 쿼리에 맞는 데이터 자체가 없을 때 snapshot이 비었기 때문에 무한 로딩이 되어서... 지금 앱에 이 코드는 쓰지 않았다.
<br>

---

굿  
<br>
